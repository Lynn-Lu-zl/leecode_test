package huawei.real.score200;

import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.Scanner;

/**
 * 题目描述
 * 当小区通信设备上报警时，系统会自动生成待处理的工单，工单调度系统需要根据不同的策略，调度外线工程师（FME）上站去修复工单对应的问题。
 *
 * 根据与运营商签订的合同，不同严重程度的工单被处理并修复的时长要求不同，这个要求被修复的时长我们称之为SLA时间。假设华为与运营商A签订了运维合同，部署了一套调度系统，只有1个外线工程师（FME），每个工单根据问题严重程度会给一个评分，在SLA时间内完成修复的工单，华为员工获得工单对应的积分，超过SLA完成的工单不获得积分，但必须完成该工单，运营商最终会根据积分付款。
 *
 * 请设计一种调度策略，根据现状得到调度结果完成所有工单，让这个外线工程师处理的工单处理的工单获得的总积分最多。
 * 假设从某个调度时刻开始，当前工单数量N，不会产生新的工单，每个工单处理修复耗时为1小时。请设计你的调度策略，完成业务目标。不考虑外线工程师在小区之间行驶的耗时。
 *
 * 输入描述
 * 第一行为一个整数N，表示工单的数量。
 * 接下来N行，每行包括两个整数，第一个整数表示工单的SLA时间（小时），第二个数表示工单的积分。
 *
 * 输出描述
 * 输入一个可以获得的最大积分
 *
 * 样例1
 * 假设有7个工单的SLA时间（小时）和积分如下：
 *
 * | 工单编号 | SLA 时间 | 积分 |
 * |    1     |    1     |  6   |
 * |    2     |    1     |  7   |
 * |    3     |    3     |  2   |
 * |    4     |    3     |  1   |
 * |    5     |    2     |  4   |
 * |    6     |    2     |  5   |
 * |    7     |    6     |  1   |

 * 最多可获得15积分，其中一个调度结果完成工单顺序为2，6，3，1，7，5，4（可能还有其他顺序）
 *
 * 输入
 * 7
 * 1 6
 * 1 7
 * 3 2
 * 3 1
 * 2 4
 * 2 5
 * 6 1

 * 输出
 * 15

 * 提示：
 * 工单数量N ≤106
 * SLA时间 ≤ 7×105
 * 答案的最大积分不会超过2147483647
 *
 * 思路分析
 * 这道题很容易就会考虑贪心算法，先对等待时间排序，时间相同，积分降序，这样简单的理解是不对的。
 *
 * 3
 * 1 2
 * 2 8
 * 2 8

 * 最大应该是16，却输出10 。
 *
 * 首先肯定是要贪心算法选时间最紧急的，必须保证处理工单的一个顺序是优先选择时间最短最紧急的，如果时间相同，那么选积分大的。这一定可以得到最优解。选择时间短的，我们仍然有机会处理后面的积分大的值。而如果先处理积分大的，那么时间短的一定会漏掉。怎么解决上面出现的问题呢？
 *
 * 这时候就可以定义一个优先队列，保存我们要处理的工单。优先级队列定义为按照积分的大小从小到大排序，即小顶堆。
 * 添加进队列的前提是输入数组已经进行贪心排序之后。然后，从第一个任务开始遍历，如果满足时间要求，加入队列。如果不满足，我们可以与当前的队头的积分进行比较，如果现在的更大，我们可以弹出队首，用当前的元素替换，因为队头元素是积分最小的。
 *
 * 最后遍历完毕后，队列中保存的一定是得到最大积分值的一个工单集合。

 */
public class 工单调度策略 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int N = in.nextInt();
        int[][] num = new int[N][2];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < 2; j++) {
                num[i][j] = in.nextInt();
            }
        }
        // 贪心算法，先按时间升序，积分降序排序，优先处理时间紧，积分大的工单
        Arrays.sort(num, (o1, o2)-> o1[0] == o2[0] ? o2[1] - o1[1] : o1[0] - o2[0]);
        // 优先队列按照积分从小到大排,最小的在堆顶
        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b)-> a[1] - b[1]);
        int curTime = 0; // 当前处理工单耗时
        int res = 0;
        for (int i = 0; i < N; i++) {
            int time = num[i][0], score = num[i][1];
            if (time > curTime) {
                curTime++;
                queue.offer(num[i]);
            } else if (!queue.isEmpty() && queue.peek()[1] < score) {
                queue.poll();
                queue.offer(num[i]);
            }
        }
        while (!queue.isEmpty()) {
            res += queue.poll()[1];
        }
        System.out.println(res);
    }

}
